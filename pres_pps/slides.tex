\documentclass[compress]{beamer}

\usepackage[utf8]{inputenc}
\usepackage[french]{babel}
\usetheme{Amsterdam}

\usepackage{multicol}
\usepackage{listings}
\usepackage{color}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}

\lstset{language=caml, frame=single, basicstyle=\ttfamily\scriptsize, commentstyle=\color{dkgreen}}

\newcommand{\email}[0]{francois.ripault@epita.fr}

\definecolor{dkgreen}{rgb}{0,0.6,0}

\defbeamertemplate*{title page}{customized}[1][]
{
  \begin{center}
  \usebeamerfont{title}\inserttitle\par
    \usebeamerfont{subtitle}\usebeamercolor[fg]{subtitle}\insertsubtitle\par
    \bigskip
    \usebeamerfont{author}\insertauthor\par
    \scriptsize \texttt{\email} \par
    \usebeamerfont{institute}\insertinstitute\par
    \vfill
    \usebeamerfont{date}\insertdate\par
    %\usebeamercolor[fg]{titlegraphic}\inserttitlegraphic
    \end{center} }

\newenvironment{tframe}[1]{
  \subsection{#1}
  \begin{frame}{#1}
  }{
  \end{frame}
  }

%% FIXME: title
\title{Presenting the new Coqdoc}

\author{François Ripault}


\begin{document}
\begin{frame}
\titlepage
\end{frame}

\begin{frame}{Introduction}
  \begin{columns}[2]

    \begin{column}{0.5\textwidth}
      What is Coqdoc ?
      \begin{itemize}
        \item Documentation tool for Coq
        \item Many possible use cases
        \item We would like to do more with it
      \end{itemize}
    \end{column}

    \begin{column}{0.5\textwidth}
      Why a new Coqdoc ?
      \begin{itemize}[<+->]
        \item Coqdoc is hard to maintain
        \item Lack of extensibility
        \item Better integration of the tool
      \end{itemize}
    \end{column}

  \end{columns}
\end{frame}

\begin{frame}
  \begin{multicols}{2}
    \small
    \tableofcontents
  \end{multicols}
\end{frame}

\section{Coqdoc-ng's architecture}
  \begin{frame}{Coqdoc-ng's architecture}
    %% FIME : pointe flèches
    \input{architecture.tex}
  \end{frame}

  \begin{tframe}{Front-end}
    Role :
    \begin{itemize}
      \item Translation into an abstract representation
      \item Multiple parsers and lexers
      \item Selected parser depends on the input file/option
    \end{itemize}

    \vfill
    Two processing phases :
    \begin{enumerate}
      \item Separation between comments, documentation and code
      \item Documentation processing
    \end{enumerate}
  \end{tframe}
  \begin{frame}{Front-end}
      Abstract representation  :
      \begin{itemize}
        \item Comments : \texttt{string}
        \item Code : \texttt{string} (for now $\ldots$)
        \item Documentation : \\
          \begin{itemize}
            \item Simple elements (content, title, horizontal rule)
            \item Recursive elements (lists, emphasis)
            \item Elements subject to evaluation (query, printing rule)
          \end{itemize}
      \end{itemize}
    \end{frame}

    \subsection{Evaluation}
    \begin{frame}[containsverbatim]{Evaluation}
    Translation for each type :
    \begin{itemize}
      \item Comments : \\
         \begin{itemize}
           \item Treat show commands : set a global state
             \begin{lstlisting}
(* begin hide *)
  some code ...
(* end hide*)
\end{lstlisting}
           \item Remove every comment
        \end{itemize}
      \item Documentation : Translate elements subject to evaluation \\
        \begin{itemize}
          \item Query : apply the function
\begin{lstlisting}
(** @query{some,arguments} *)
\end{lstlisting}

          \item Printing rule : set a new printing rule in the global state
          \item Apply the printing rules on the rest
        \end{itemize}
      \item Code : interaction with Coqtop
    \end{itemize}
  \end{frame}


  \begin{tframe}{Interaction with Coqtop}
    Why interact with Coqtop ?
    \begin{itemize}[<+->]
      \item Remove code processing in Coqdoc
      \item Xml protocol (already used by CoqIDE)
      \item Easy to add new mechanisms
    \end{itemize}
    \vfill
    Objectives for code processing :
    \begin{itemize}
      \item Indentation
      \item Syntactic coloration
      \item Identifier processing
      \item Notations processing %%FIXME
    \end{itemize}
  \end{tframe}

  \begin{tframe}{New commands : \texttt{locate} and \texttt{prettyprint}}
    \begin{itemize}
      \item \texttt{locate} : locates an identifier
        \begin{itemize}
          \item From a name, returns its ``absolute'' name
          \item Generate hyperlinks between different modules being documented
          \item Easy to implement
        \end{itemize}
        \vfill
      \item \texttt{prettyprint} : indents and annotates code
        \begin{itemize}
          \item Coqtop indents and tags each element
          \item Coqdoc translates the tags into final elements \\
            \small (syntactic coloration, processing of identifiers, $\ldots$)
          \item Hard to do : no good level of abstraction \\
            \small (lack of a concrete syntax tree)
        \end{itemize}
    \end{itemize}
  \end{tframe}

  \begin{tframe}{An imperfect solution for Prettyprint}

    Method :
    \begin{itemize}
      \item Use Coq's \texttt{Printing} module
      \item Annotate the output with tags
      \item Semantic kept and indentation obtained
    \end{itemize}
    Implementation :
    \begin{itemize}
      \item Make tags based on AST types (VernacExpr and ConstrExpr)
      \item Each node translation is surrounded with a tag function
      \item Generates Xml content carrying the tags
    \end{itemize}
  \end{tframe}

  \begin{frame}[containsverbatim]{Code modification example}
  Before:
    \begin{lstlisting}
(* some code *)
| CApp (_,(None,a),l) -> pr_app (pr mt) a l, lapp
(* some code *)
    \end{lstlisting}

    After :
    \begin{lstlisting}
(* some code *)
| CApp (_,(None,a),l) ->
  tag C_CApp (pr_app (pr mt) a l), lapp
(* some code *)
    \end{lstlisting}

    The \texttt{tag} function surrounds the output with XML tags
  \end{frame}

  \begin{tframe}{Processing rules for the code}
    Main tasks :
    \begin{itemize}
      \item Annotate code for syntactic coloration
      \item Apply printing rules
      \item Process identifiers
    \end{itemize}
    \vfill
    Chain of control design pattern :
    \begin{itemize}
      \item Easy to add rules
      \item Extensible
      \item Multiple rules applied on a same node
    \end{itemize}
    Output : better type for representing code
  \end{tframe}

  \begin{frame}{Code type}
    Three main code types :
    \begin{itemize}
      \item Formatting : keywords, literals, tactics, $\ldots$
      \item Identifiers : contain hyperlinks
      \item No format
    \end{itemize}
  \end{frame}

  \begin{tframe}{Identifiers}
    Identifier processing chain :
    \begin{itemize}
      \item \texttt{locate} each identifier
      \item Ignore undeclared identifiers
      \item Special cases for standard library or external library
      \item Generate a link type used in the output module.
    \end{itemize}
  \end{tframe}

  \begin{tframe}{Back-end}
    Back-end structure
    \begin{itemize}
      \item Central module in charge of printing
      \item Specification modules for each output type
        \begin{itemize}
          \item Printing functions for each type (documentation and code)
          \item Hyperlink generation function
          \item Index generation functions
        \end{itemize}
    \end{itemize}
  \end{tframe}

\section{Extending Coqdoc : Coq-tex}
  \begin{tframe}{Extending Coqdoc : Coq-tex}
    \begin{itemize}[<+->]
      \item Add a new frontend
      \item Process queries
      \item Use the LaTeX backend
      \item Add Coq-tex options to Coqdoc
    \end{itemize}
  \end{tframe}

\section{Demo}
  \begin{tframe}{Demo}
    \begin{center}
      Demo
    \end{center}
  \end{tframe}

\section{Remaining work}
  \begin{tframe}{What's left to do}
    \begin{itemize}
      \item Bugfixes
      \item Retro-compatibility (mostly options)
      \item Clean errors
    \end{itemize}
  \end{tframe}
  \begin{tframe}{New possibilities for Coqdoc}
    \begin{itemize}
      \item FIXME
    \end{itemize}
  \end{tframe}

\section{Conclusion}
  \begin{tframe}{Conclusion}
  \end{tframe}

\end{document}
